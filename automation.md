## Docker to power CI/CD pipeline (with Jenkins)
We wanna build a CI/CD pipeline like [this](https://prnt.sc/ug0j67).
We are going to use [Jenkins](https://jenkins. io) as automation server.
The central document is the `Jenkinsfile` which will contain the definition of the pipeline with its multiple stages.
A typical Jenkins file with `Build,Test,Deploy to Staging, Deploy to Production` is:
```
pipeline {
    agent any
    options {
        skipStagesAfterUnstable()
    }
    stages {
        stage('Build') {
            steps {
                echo 'Building'
            }
        }
        stage('Test') {
            steps {
                echo 'Testing'
            }
        }
        stage('Deploy to Staging') {
            steps {
                echo 'Deploying to Staging'
            }
        }
        stage('Deploy to Production') {
            steps {
                echo 'Deploying to Production'
            }
        }
    }
}
```
1. We have to create a folder and run a Jenkins container inside:
```sh
docker run --rm -d --name jenkins -u root -p 8080:8080 -v jenkins-data:var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v "$HOME":/home jenkinsci/blueocean
```
NB = we are running as the root user inside the container and that we are
mounting the Docker socket into the container (-v /var/run/docker.sock:/var/run/docker.sock) so that Jenkins can access Docker from within the container.
2. Next we can find the initial admin password generated by Jenkins
```sh
docker container exec jenkins cat
```
3. Navigate to `http://localhost:8080` and install the suggested plugins, then create the admin account.
4. Click on `New Item` and assign to it a project name, then select `Pipeline type` and paste the configuration of the pipeline (script) that you can see above. Click `Save` and then `Build Now`
5. We can initialize the previously created folder as a Git project and insert all the file that we want. 
```sh
cd /foldername && git init
```
6. We have to create some unit test and configure the test framework choosen for the application
7. We have to configure and push the files to the Github repo.
8. Then [configure](https://prnt.sc/ug6ycz) the Jenkins Pipeline to pull from the Github repo and use the Jenkinsfile to define the pipeline (must be located in the root of the project)
A more complex Jenkinsfile could be:
```
pipeline {
    environment { //Define two env variables
        registry = "username/jenkins-docker-test"
        DOCKER_PWD = credentials('docker-login-pwd') //Docker Hub pass
    }
    agent {
        docker {
            image 'username/node-docker'
            args '-p 3000:3000'
            args '-w /app'
            args '-v /var/run/docker.sock:/var/run/docker.sock'
        }
    }
    options {
        skipStagesAfterUnstable()
    }
    stages {
        stage("Build"){
            steps {
                sh 'npm install'
            }
        }
        stage("Test"){
            steps {
                sh 'npm test'
            }
        }
        stage("Build & Push Docker image") {
            steps {
                sh 'docker image build -t $registry:$BUILD_NUMBER
                sh 'docker login -u username -p $DOCKER_PWD'
                sh 'docker image push $registry:$BUILD_NUMBER'
                sh "docker image rm $registry:$BUILD_NUMBER"
            }
        }
    }
}
```
9. We can push the updated files to the repo and Jenkins will update the pipeline with the new steps


### Unit Tests
Unit tests assert the correctness and quality of an individual, isolated piece of the overall application or application service.

### Integration Tests
Integration tests make sure that pieces that are closely related work together as expected.

### Stress and Load Tests
Stress and load tests often take the application or service as a whole and assert a correct behavior under various edge cases such as high load
through multiple concurrent requests handled by the service, or by flooding the service with a huge amount of data.

### End-to-End Tests
End-to-End tests simulate a real user working with the application or application service. Can be done using Selenium Web Driver.

The code or component under test is often called a `System Under Test(SUT)`.

Unit tests are in their nature tightly coupled to the actual code or SUT. It is, hence, necessary that those tests run in the same context as the code under test. Hence, the test code lives in the same container as the SUT. All external dependencies of the SUT are either
mocked or stubbed. Integration tests, stress and load tests, and end-to-end tests, on the other hand, act on public interfaces of the system under test and it is, hence, most common to run that test code in a separate container.

